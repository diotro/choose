#! /bin/sh -e
# by Thomas Monjalon

print_help () {
	cat <<- END_OF_HELP
		It returns on stdout the chosen line among the ones submitted via stdin.
		Apart result, all is printed on stderr.

	END_OF_HELP
	print_usage
}

print_usage () {
	cat <<- END_OF_USAGE
		usages:
		         command_which_print_choices | $B$SELF$S [${U}options$S] [${U}default choice$S]
		         $B$SELF$S [${U}options$S] [${U}default choice$S] < file_of_choices
		options:
		         ${B}-c$S   cursor mode (default)
		         ${B}-n$S   numerated mode
		         ${B}-r$S   reversed theme (default)
		         ${B}-a$S   arrow theme
		         ${B}-q$S   quiet = clean all on exit
		         ${B}-v$S   verbose = keep menu on exit
		         ${B}-h$S   help
	END_OF_USAGE
}

alert () { # <comment>
	echo $SELF: "$@"
	exit 1
}

set_defaults () {
	unset DEFAULT
	MODE=cursor
	THEME=reversed
	CLEAN=keepchoice
	N=0
	INDENT='    '
	ARROW='=>'
	unset TTY_SAVE
}

handle_args () { # <arguments>
	local ARG
	SELF=$(basename $0)
	while getopts cnraqvh ARG ; do
		case $ARG in
			c ) MODE=cursor ;;
			n ) MODE=numerated ;;
			r ) THEME=reversed ;;
			a ) THEME=arrow ;;
			q ) CLEAN=all ;;
			v ) CLEAN=none ;;
			h ) print_help ; exit 0 ;;
		esac
	done
	shift $((OPTIND - 1))
	DEFAULT=$*
}

check_input () {
	if ! has_batch_input ; then
		print_usage
		alert 'no input'
	fi
}

has_batch_input () {
	test ! -t 0
}

is_redirected () {
	test ! -t 2
}

isdigit () { # <string>
	test $# -eq 1
	case $1 in
		*[!0-9]* | '') false ;;
	esac
}

code2hex () { # < bytes
	od -t x1 | head -n1 | cut -d' ' -f2- | tr -d ' '
}

get_key_codes () {
	# ENTER
	TTY_ENT=$(echo | code2hex)
	TTY_KENT=$(tput kent | code2hex)
	# UP
	TTY_CUU1=$(tput cuu1 | code2hex)
	TTY_KCUU1=$(tput kcuu1 | code2hex)
	# DOWN
	TTY_CUD1=$(tput cud1 | code2hex)
	TTY_KCUD1=$(tput kcud1 | code2hex)
	# some terminals send the wrong code for certain arrow keys
	if [ "$TTY_CUU1" = 1b5b41 -o "$TTY_KCUU1" = 1b5b41 ] ; then
		TTY_CUDX=1b5b42
	fi
}

configure_tty () {
	TTY_SAVE=$(stty -g)
	stty cs8 -icanon -echo
}

restore_tty () {
	test -z "$TTY_SAVE" || stty $TTY_SAVE >&- 2>&-
}

set_fancy_output () {
	if is_redirected ; then
		unset S B U R
	else
		S=$(printf '\033[0m') # standard
		B=$(printf '\033[1m') # bold
		U=$(printf '\033[4m') # underlined
		R=$(printf '\033[7m') # reversed
	fi
}

cursor_begin () {
	printf '\033[s' # save position
	printf "\033[$((COUNT - N + 1))A" # go up to current line
}

cursor_home () {
	printf "\033[${WIDTH}D" # go to beginning of line
}

cursor_end () {
	printf '\033[u' # restore position at the bottom
}

cursor_erase () {
	cursor_begin
	if [ $THEME = arrow ] ; then
		printf $ARROW | sed 's,., ,g'
	else
		printf "$(print_current_line | format_simple)"
	fi
	cursor_home
}

cursor_draw () {
	if [ $THEME = arrow ] ; then
		printf $ARROW
	else
		printf "$(print_current_line | format_$THEME)"
	fi
	cursor_end
}

cursor_init () {
	cursor_begin
	cursor_draw
}

cursor_move_up () {
	if [ $N -gt 1 ] ; then
		cursor_erase
		printf '\033[A' # go to upper line
		N=$((N - 1))
		cursor_draw
	fi
}

cursor_move_down () {
	if [ $N -lt $COUNT ] ; then
		cursor_erase
		printf '\033[B' # go to lower line
		N=$((N + 1))
		cursor_draw
	fi
}

clean_menu () {
	printf "\033[${CLEAN_COUNT}A" # go to first line
	printf '\033[J' # clean lines from this point
	[ $CLEAN = all ] || print_current_line | format_$THEME
}

truncate () { # <width>
	while read LINE ; do
		# fold count the tab space unlike cut
		printf "$LINE\n" | fold -w$1 | head -n1
	done
}

format_simple () { # < lines
	truncate $((WIDTH - ${#INDENT})) | sed "s,^,$INDENT,"
}

format_arrow () { # < lines
	format_simple | sed "s,^..,$ARROW,"
}

format_reversed () { # < lines
	truncate $((WIDTH - ${#INDENT})) | sed "s,\(.*\),$INDENT$R\1$S,"
}

filter_default () { # < lines
	if [ -n "$DEFAULT" ] ; then
		if [ $THEME = arrow ] ; then
			sed "s,^..\( *[0-9]*[	 ]*$DEFAULT\)$,$ARROW\1,"
		else
			sed "s,^\( *[0-9]*[	 ]*\)\($DEFAULT\)$,\1$R\2$S,"
		fi
	else
		cat
	fi
}

get_default_index () {
	if [ -n "$DEFAULT" ] ; then
		echo "$LINES" | sed -n "/^$DEFAULT$/=" | head -n1
	fi
}

print_current_line () {
	echo "$LINES" | sed -n ${N}p
}

numerated_list () {
	echo "$LINES" | cat -n | filter_default
}

cursor_list () {
	WIDTH=$(stty size | cut -d' ' -f2)
	echo "$LINES" | format_simple
	N=$(get_default_index)
	isdigit "$N" || N=1 # fallback to first choice
	configure_tty
	cursor_init
}

numerated_choice () { # < user input
	WIDTH=1000 # arbitrary
	while : ; do
		printf "> "
		read N
		CLEAN_COUNT=$((CLEAN_COUNT + 1))
		test -n "$N" || N=$(get_default_index) # ENTER = default choice
		isdigit "$N" || N=0 # fallback to invalid choice
		[ $N -lt 1 -o $COUNT -lt $N ] || break
	done
}

cursor_choice () { # < user input
	get_key_codes
	local KEY
	while : ; do
		KEY=$(dd bs=4 count=1 2>&- | code2hex)
		case $KEY in
			"$TTY_ENT"  | "$TTY_KENT"                ) break ;;
			"$TTY_CUU1" | "$TTY_KCUU1"               ) cursor_move_up ;;
			"$TTY_CUD1" | "$TTY_KCUD1" | "$TTY_CUDX" ) cursor_move_down ;;
		esac
	done
}

clean () {
	[ $CLEAN = none ] || clean_menu
	restore_tty
}

set_exit_handler () {
	trap "clean ; exit 1" INT QUIT TERM
}

{ # main
	set_defaults
	set_fancy_output
	handle_args "$@"
	check_input
	LINES=$(grep -v '^$') # get standard input without blank lines
	COUNT=$(echo "$LINES" | wc -l)
	CLEAN_COUNT=$COUNT
	set_exit_handler
	{
		${MODE}_list
		if [ $COUNT -le 1 ] ; then
			N=1 # no choice
		else
			${MODE}_choice
		fi
		clean
	} </proc/$PPID/fd/0 # get terminal input
} >&2
print_current_line # return chosen line on standard output
